///////////////////////////////////////////////////
// Score Position [bars, beats, divisions, tick] //
///////////////////////////////////////////////////
Pos {
    var bar, beat, division, tick;

    *new { |bar=0, beat=0, division=0, tick=0|

        ^super.new.init(bar, beat, division, tick);
    }

	init {
		arg bar, beat, division, tick;

		this.bar = bar.asInteger;
		this.beat = beat.asInteger;
		this.division = division.asInteger;
		this.tick = tick.asInteger;

		^this
	}

	bar { ^bar }
	beat { ^beat }
	division { ^division }
	tick { ^tick }

	bar_ { arg inval; bar = inval.asInteger }
	beat_ { arg inval; beat = inval.asInteger }
	division_ { arg inval; division = inval.asInteger }
	tick_ { arg inval; tick = inval.asInteger }

	copy {
		arg bar = this.bar, beat = this.beat, division = this.division, tick = this.tick;

		^Pos.new(bar, beat, division, tick)
	}


    asString {
        ^"Pos[% % % %]".format(bar, beat, division, tick);
	}
}

//////////////////////////
// Metre
//////////////////////////
Metre {
    var beats, divisions, tpqn;

    *new {
		arg beats=[1,1,1,1], divisions=[4,4,4,4], tpqn=960;

		^super.new.init(beats, divisions, tpqn);
    }

	init {
		arg inBeats, inDivisions, inTPQN;

		inDivisions.do { |val, i|
			if (val.isInteger.not or: { val <= 0 }) {
				("Invalid division at index %: must be positive integer.".format(i)).throw;
			};
		};

		if (inBeats.size != inDivisions.size) {
			inDivisions = inBeats.size.collect({ arg i; inDivisions.wrapAt(i) });
			("divisions was altered to match beats: " ++ inDivisions).warn;
		};

		beats = inBeats.copy;
		divisions = inDivisions.copy;
		tpqn = inTPQN.asInteger;
	}

	//////////////
	// GETTERS
	//////////////
	beats { ^beats.copy }
	divisions { ^divisions.copy }
	tpqn { ^tpqn }

	== {
		arg other;

		var beats = this.beats == other.beats;
		var divisions = this.divisions == other.divisions;
		var tpqn = this.tpqn == other.tpqn;

		if (other.isKindOf(Metre).not) { ^false };

		^(beats && divisions && tpqn);
	}

	asString {

		^"Metre(%, %)".format(beats, divisions)
	}
}

//////////////////////////
// MetreRegion
//////////////////////////
MetreRegion {
	var start, metre;

	*new {
		arg start, metre;

		^super.new.init(start, metre)
	}

	init {
		arg startArg, metreArg;

		if (metreArg.isKindOf(Metre).not) {
			("MetreRegion: 'metre' argument must be an instance of Metre, got: %".format(metreArg.class)).throw;
		};

		start = startArg.floor.asInteger;
		metre = metreArg;

		^this
	}

	start { ^start }
	metre { ^metre }

	copy {
		arg
		start = this.start,
		metre = this.metre;

		^MetreRegion.new(start, metre)
	}

	asString {
		^"Region(start: % || metre: %)".format(start, metre)
	}
}

//////////////////////////
// MetreMap
//////////////////////////
MetreMap {
	var <>regions, tpqn;

	*new {
		^super.new.init
	}

	init {
		regions = List.new;
		^this;
	}

	tpqn { ^tpqn }

	add {|region|
		var matchIdx, insertionIdx;

		if (tpqn.isNil) { tpqn = region.metre.tpqn };

		if (region.isKindOf(MetreRegion).not) {
			"can only add MetreRegion objects to MetreMap".warn;
			^this
		};

		if (regions.isEmpty) { regions.add(region); ^this };

		// equality check on start value
		matchIdx = this.matchingRegionStartIndex(region); // returning nil
		if (matchIdx.notNil) {
			regions.put(matchIdx, region);
			this.pushDownstream(region);
			^this
		};

		if (this.isEarliest(region)) {
			// add region as first region
			regions.addFirst(region);
			this.pushDownstream(region);
			^this
		};

		// in between or at end
		insertionIdx = this.insertionIndex(region.start);

		if (this.isBarAligned(region)) {
			regions.insert(insertionIdx, region);
			this.pushDownstream(region);
			^this
		};

		region = this.snapToLastBarline(region);

		matchIdx = this.matchingRegionStartIndex(region);
		if (matchIdx.notNil) {
			regions.put(matchIdx, region);
			this.pushDownstream(region);
			^this
		};

		regions.insert(insertionIdx, region);
		this.pushDownstream(region);
		^this
	}

	// to utils
	isEmpty {
		^regions.isEmpty
	}

	// IMPLEMENT COPY .. for VOX PLUG
}
/////////////////////////////////////////////////////////////////////////////
// Vox: a container for composed material, for further creative processing //
/////////////////////////////////////////////////////////////////////////////
Vox : VoxNode {
	classvar idCounter=0;
	var <events, metremap, range, <tpqn;
	var <history;
	var <>id;
	var <>parentVoxMulti;

	assignId {
		id = idCounter;
		idCounter = idCounter + 1;
	}

	// TODO: JUST CHECK METREMAP AUTOMATICALLY CALLS THE GETTER ... ELSE this.metremap NEEDED

	//////////////////
	// CONSTRUCTORS //
	//////////////////
	*new {
		arg events, metremap, label = \anonyvox;

		^super.new.init(events, metremap, label);
	}

	init { |eventsArg, metremapArg, labelArg|
		events = eventsArg ?? [];
		label = labelArg;
		metremap = metremapArg ?? MetreMap.new;
		tpqn = this.metremap.tpqn; // default is 960 on MetreMap

		// ensure metremap has a metre
		metremap.isEmpty.if {
			metremap.add(MetreRegion.new(0, Metre([1, 1, 1, 1], [4, 4, 4, 4])));
		};

		// sort events
		events.isEmpty.not.if {
			events = events.sortBy(\absTime)
		};

		// add Pos values to events
		this.calculatePositions;

		// set highlight to span the entire voice.
		this.highlightAll;

		metadata = Dictionary.new;

		// history created with Vox, and snapshot of full Vox is init commit
		history = VoxHistory.new;
		history.commit(VoxPlug.new(events, metremap, label, metadata, this), "init commit");

		this.assignId;

		^this
	}

	calculatePositions {
		events.do {
			arg e;
			e[\position] = TimeConverter.ticksToPos(e[\absTime], metremap);
		}
	}

	earliestEventStart {
		^events.first[\absTime];
	}

	latestEventEnd {
		^events.last[\absTime] + events.last[\dur]
	}

	normaliseRange { |rangeArg|
		var start, end;

		// Ensure it's a 2-element array-like input
		if (rangeArg.isKindOf(SequenceableCollection).not or: { rangeArg.size != 2 }) {
			"Vox.normaliseRange: Expected a 2-element array as input.".warn;
			^[0, 0]
		};

		start = rangeArg[0].abs;
		end = rangeArg[1].abs;

		if (start.isNumber.not or: { end.isNumber.not }) {
			"Vox.normaliseRange: Expected a 2-element array of numbers as input.".warn;
			^[0, 0]
		};

		if (end < start) {
			var temp = start;
			start = end;
			end = temp
		};

		^[start, end]
	}

	// for internal use only
	setRange { |rangeArg|
		range = rangeArg;
		^this
	}

	// for internal use only
	setNormRangeAndNotify { |rangeArg|
		var normRange = this.normaliseRange(rangeArg);
		this.setRange(normRange);

		parentVoxMulti.notNil.if {
			parentVoxMulti.mirrorVoxHighlight(normRange);
		};

		^this
	}

	// for internal use only
	// Called by VoxMulti
	mirrorRangeFromMulti { |rangeArg|
		var normRange = this.normaliseRange(rangeArg);
		this.setRange(normRange);
	}

	highlightAll {
		var first = events.first;
		var last = events.last;

		this.isEmpty.if {
			range = [0,0];
		} {
			var rangeArg;

			rangeArg = [first.absTime, last.absTime + last.dur];

			// set range on Vox, and check for parent VoxMulti
			this.setNormRangeAndNotify(rangeArg);
		};

		^this
	}

	isEmpty {
		^events.isEmpty
	}

	*fromMIDI {
		arg midifile, label = \anonyvox;

		^super.new.initFromMIDI(midifile, label)
	}

	initFromMIDI {
		arg midifileArg, labelArg;
		var timesigArrs;

		label = labelArg;
		tpqn = midifileArg.division;

		// get metremap from time sig info
		// define fromTimeSigEvents on MetreMap later
		timesigArrs = midifileArg.timeSignatureEvents;
		metremap = MetreMap.new;
		// for each timeSig, create MetreRegion entry
		timesigArrs.do({
			arg timeSigArr;
			metremap.add(MetreRegion(
				timeSigArr[0],
				TimeConverter.midiTimeSigToMetre(timeSigArr.last, tpqn))
			);
		});

		events = this.noteSustainEventsToVoxEvents(midifileArg.noteSustainEvents);

		// set highlight to span the entire voice if possible
		this.highlightAll;

		label = labelArg;

		metadata = Dictionary.new;

		history = VoxHistory.new;
		history.commit(VoxPlug.new(events, metremap, label, metadata, this), "init commit");

		this.assignId;

		^this
	}

	noteSustainEventsToVoxEvents { |noteSustainEvents|
		var eventsArr;
		eventsArr = noteSustainEvents.collect({
			arg nse;
			var event;
			event = Event.newFrom([[\track, \absTime, \midicmd, \channel, \midinote, \velocity, \dur, \upVelo], nse].lace);
		});

		eventsArr.sortBy(\absTime);
		eventsArr.do({
			arg event;
			event[\position] = TimeConverter.ticksToPos(event[\absTime], metremap);
		});

		^eventsArr;
	}

	*fromPlug {
		arg plug;
		var vox = this.new(
			plug.events,
			plug.metremap,
			plug.label
		);
		plug.respondsTo(\source).if {
			vox.metadata[\source] = plug.source;
		};
		^vox
	}

	highlight { |startPos, endPos|
		var start, end;

		start = TimeConverter.posToTicks(startPos, metremap);
		end = TimeConverter.posToTicks(endPos, metremap);

		^this.setNormRangeAndNotify([start, end]);
	}

	tickHighlight { |startTick, endTick|
		range = this.normaliseRange([startTick, endTick]);
		^this;
	}

	// Only called from a VoxMulti, when VoxMulti highlighted
	multivoxHighlight { |startTick, endTick|
		range = [startTick, endTick];
		// no return necessary
	}

	highlighted {
		^"% --> %".format(range[0].toPos(metremap), range[1].toPos(metremap))
	}

	getRange {
		^range
	}

	metremap {
		parentVoxMulti.notNil.if {
			^parentVoxMulti.metremap
		} {
			^metremap
		}
	}

	metremap_ { |mm|
		if (parentVoxMulti.notNil) {
			"😬 Cannot set metremap directly on a Vox inside a VoxMulti".warn;
			^this
		};

		metremap = mm;
		tpqn = mm.tpqn;

		if (events.notEmpty) {
			events.do { |event|
				event[\position] = TimeConverter.ticksToPos(event[\absTime], this.metremap);
			}
		}
	}

	asString {
		^"Vox(%)".format(label);
	}

	duration {
		^(range[1] - range[0]);
	}

	// to utils?
	clip {
		^this.clipRange(range);
    }

	clipRange { |rangeArg|
		var rangeStart = rangeArg[0], rangeStartPos;
        var rangeEnd = rangeArg[1], rangeEndPos;
		var events, return = [];
		var vox;

		events = this.events.deepCopy;

		return = events.select({
			arg event;

			var eventStart = event[\absTime];
			var eventEnd = eventStart + event[\dur];

			(eventStart < rangeEnd) and: (eventEnd > rangeStart);

		}).do({
			arg event;

			var eventStart = event[\absTime];
			var eventEnd = eventStart + event[\dur];

			if ((eventStart < rangeStart) && (eventEnd > rangeStart)) {
				event[\dur] = eventEnd - rangeStart;
				event[\absTime] = rangeStart;
			};

			if ((eventStart < rangeEnd) && (eventEnd > rangeEnd)) {
				event[\dur] = rangeEnd - eventStart;
			}
		});

		// create label
		rangeStartPos = TimeConverter.ticksToPos(rangeStart, metremap);
		rangeEndPos = TimeConverter.ticksToPos(rangeEnd, metremap);

		vox = Vox.new(return, metremap, label);
		vox.metadata[\clip_origin] = this;

		^vox;
	}

	merge { |source|
		var plug = source.respondsTo(\out).if {
			source.out
		} {
			"Vox.merge: Requires VoxNode as input".warn;
			^this
		};

		// if VoxPlug, replace if label match, combine together if not
		if (plug.isKindOf(VoxPlug)) {
			if (plug.label == this.label) {
				^Vox.fromPlug(plug);
			} {
				^VoxMulti.new([this.copy, Vox.fromPlug(plug)], plug.metremap, this.label);
			}
		};

		// if plug is PlugMulti, replace match, combine with non-matches
		if (plug.isKindOf(VoxPlugMulti)) {
			var match = plug[this.label];
			var voxes;

			if (match.notNil) {
				var otherPlugs = plug.asArray.reject({ |p| p.label == this.label });
				voxes = [match] ++ otherPlugs;
			} {
				voxes = [this.copy] ++ plug.asArray;
			};

			voxes = voxes.collect(Vox.fromPlug(_));
			^VoxMulti.new(voxes, plug.metremap, this.label);
		};

		"Vox.merge: Unrecognized plug type %".format(plug.class).warn;
		^this
	}

	load { |source, strict=true|

		var plug, startTick, endTick;

		// resolve plug
		plug = source.isKindOf(VoxNode).if {
			source.out
		} {
			source // assume VoxPlug
		};

		if (plug.isKindOf(VoxPlug).not) {
			"❌ Vox.load: Expected VoxPlug or VoxNode with .out, got %"
			.format(plug.class).warn;
			^this
		};

		// is there ever a situation where I want to load VoxMulti?

		if (strict and: { plug.label != this.label }) {
			"❌ Vox.load: Plug label % ≠ Vox label %"
			.format(plug.label, this.label).warn;
			^this
		};

		// otherwise process
		startTick = plug.events.first[\absTime];
		endTick = plug.events.last[\absTime] + plug.events.last[\dur];

		events = events.reject { |e|
			e[\absTime] < endTick and: { (e[\absTime] + e[\dur]) > startTick }
		} ++ plug.events;

		events.sortBy(\absTime);

		if (this.duration == 0) {
			this.highlightAll;
		};

		^this
	}

	// some tidy-up to do (range etc.)
	forceload { |source|
		this.load(source, false);
		if (this.duration == 0) {
			this.highlightAll;
		};
		^this
	}

	loadFromEvents { |eventsArg, metremapArg, labelArg|
		if (eventsArg.isNil or: { eventsArg.isEmpty }) {
			"❌ Vox.loadFromEvents: No events provided".warn;
			^this
		};

		^this.forceload(Vox.new(eventsArg, metremapArg, labelArg));
	}

	commit { |label = nil|

		parentVoxMulti.isNil.if {
			history.commit(this.out, label);
		};

		"❌ Vox(%).commit: cannot commit to Vox history from within VoxMulti. Use VoxMulti.commit instead.".format(this.label).warn;
	}

	undo {
		parentVoxMulti.isNil.if {
			this.input = history.undo.plug;
		};

		"❌ Vox(%).commit: cannot undo Vox history from within VoxMulti. Use VoxMulti.undo instead.".format(this.label).warn;
	}

	redo {
		parentVoxMulti.isNil.if {
			this.input = history.redo.plug;
		};

		"❌ Vox(%).commit: cannot undo Vox history from within VoxMulti. Use VoxMulti.undo instead.".format(this.label).warn;
	}

	out {
		// Everything copied in VoxPlug
		^VoxPlug.new(
			this.clip(range).events,
			metremap,
			label,
			metadata,
			this
		)
	}
}

VoxMulti : VoxNode {
	var <voxes, <history, range, <metremap, <>tpqn;

	*new { |voxes, metremap, label|
		^super.new.init(voxes, metremap, label);
	}

	init { |voxesArg, metremapArg, labelArg|

		label = labelArg ? \anonyvoxmulti;
		metadata = Dictionary.new;

		voxesArg.notNil.if {
			var labels;
			labels = voxesArg.collect(_.label);
			voxes = Dictionary.newFrom([labels, voxesArg].lace);
		} {
			voxes = Dictionary.new;
		};

		metremap = metremapArg ?? {
			voxes.notEmpty.if {
				voxes.values.first.metremap // bit arbitrary
			} {
				MetreMap.new
			}
		};

		// ensure metremap has a metre
		metremap.isEmpty.if {
			metremap.add(MetreRegion(0, Metre([1, 1, 1, 1], [4, 4, 4, 4])));
		};

		// vox updates
		voxes.notEmpty.if {
			voxes.values.do({ arg vox, i;
				vox.parentVoxMulti = this;
				vox.calculatePositions; // based on parent metremap
			})
		};

		tpqn = metremap.tpqn;

		this.highlightAll;

		history = VoxHistory.new;
		history.commit(this.out, "init commit"); // check this ...

		^this
	}

	*fromMIDI {
		// TODO: implement
	}

	initFromMIDI {
		// TODO: implement
		// get tracks and tracknames ...
	}

	*fromDict { |voxesDict, metremap, label|
		^super.new.initFromDict(voxesDict, metremap, label)
	}

	initFromDict { |voxesDict, metremapArg, labelArg|

		voxes = voxesDict ? Dictionary.new;
		label = labelArg ? \anonyvoxmulti;
		metadata = Dictionary.new;

		metremap = metremapArg ?? {
			voxes.notEmpty.if {
				voxes.values.first.metremap // bit arbitrary
			} {
				MetreMap.new
			}
		};

		// ensure metremap has a metre
		metremap.isEmpty.if {
			metremap.add(MetreRegion(0, Metre([1, 1, 1, 1], [4, 4, 4, 4])));
		};

		// vox updates
		voxes.notEmpty.if {
			voxes.values.do({ arg vox, i;
				vox.parentVoxMulti = this;
				vox.calculatePositions; // based on parent metremap
			})
		};

		tpqn = metremap.tpqn;

		this.highlightAll;

		history = VoxHistory.new;
		history.commit(this.out, "init commit"); // check this ...

		^this
	}

	*fromPlugMulti { |plugMulti|
		var voxesArg;

		// Safety check
		if (plugMulti.isNil or: { plugMulti.plugs.isNil }) {
			"❌ Cannot create VoxMulti from nil plugMulti; empty VoxMulti returned".warn;
			^this.new;
		};

		voxesArg = plugMulti.plugs.values.collect { |plug|
			Vox.new(plug.events, plug.metremap, plug.label);
		};

		voxesArg.do({ arg v; v.input })

		^VoxMulti.new(voxesArg, plugMulti.metremap, plugMulti.label);
	}

	normaliseRange { |rangeArg|
		var start, end;

		// Ensure it's a 2-element array-like input
		if (rangeArg.isKindOf(SequenceableCollection).not or: { rangeArg.size != 2 }) {
			"😬 Vox.normaliseRange: Expected a 2-element array as input.";
			^[0, 0]
		};

		start = rangeArg[0];
		end = rangeArg[1];

		if (end < start) {
			var temp = start;
			start = end;
			end = temp
		};

		^[start, end]
	}

	setRangeAndPropagate { |rangeArg|
		var normRange = this.normaliseRange(rangeArg);
		this.setRange(normRange);
		this.propagateRangeToVoxes;
		^this
	}

	propagateRangeToVoxes {
		voxes.values.do{
			arg vox;
			vox.mirrorRangeFromMulti(range);
		}
	}

	// for internal use
	setRange { |rangeArg|
		range = rangeArg;
		^this
	}

	highlightAll {
		var starts, ends;

		if (this.isEmpty) {
			this.setRangeAndPropagate([0, 0]);
		} {
			starts = voxes.values.collect { arg v; v.earliestEventStart };
			ends = voxes.values.collect { arg v; v.latestEventEnd };
			this.setRangeAndPropagate([starts.minItem, ends.maxItem]);
		};

		^this
	}

	highlight { |startPos, endPos|
		var start = TimeConverter.posToTicks(startPos, metremap);
		var end   = TimeConverter.posToTicks(endPos, metremap);
		this.setRangeAndPropagate([start, end]);
		^this
	}

	mirrorVoxHighlight { |rangeArg|
		var normRange = this.normaliseRange(rangeArg);
		this.setRange(normRange);
		^this
	}

	highlighted {
		var start = range[0].toPos(metremap);
		var end   = range[1].toPos(metremap);
		^"% --> %".format(start, end);
	}

	isEmpty {
		^voxes.isEmpty or: {
			voxes.values.every(_.isEmpty)
		}
	}

	duration {
		^(range[1] - range[0]);
	}

	at { |key|
		var vox = voxes[key];

		// THIS COULD BECOME PROBLEMATIC, RETURN TO THIS
		// RETURNING EMPTY VOX MIGHT BE BETTER DEFAULT
		// BEHAVIOUR
		if (vox.isNil) {
			"VoxMulti.at: No Vox found for key %; returning this VoxMulti".format(key).warn;
			^this;
		};

		// does a copy need to be made???
		vox = vox.deepCopy;
		vox.parentVoxMulti = nil;
		vox.highlightAll;
		^vox;
	}


	clip {
		var clippedVoxes;

		clippedVoxes = voxes.collect({
			arg vox;
			vox.clipRange(range);
		});

		^VoxMulti.new(clippedVoxes, metremap, label);
	}

	merge { |source|
		var plug = source.respondsTo(\out).if {
			source.out
		} {
			source
		};

		var newVoxes = voxes.deepCopy;

		if (plug.isKindOf(VoxPlug)) {
			// if exists, replaces, else creates
			newVoxes[plug.label] = Vox.fromPlug(plug);

			^VoxMulti.fromDict(newVoxes, plug.metremap, this.label);
		};

		// add voxmulti, check for matches, replace etc.
		if (plug.isKindOf(VoxPlugMulti)) {
			plug.asArray.do({ |p|
				// if exists, replaces, else creates
				newVoxes[p.label] = Vox.fromPlug(p);
			});

			^VoxMulti.fromDict(newVoxes, plug.metremap, this.label);
		};

		"VoxMulti.merge: Unrecognized plug type %".format(plug.class).warn;
		^this
	}

	load { |source, strict = true|

		var plug = source.isKindOf(VoxNode).if {
			source.out
		} {
			source
		};

		// if empty and not strict, load
		this.voxes.isEmpty.if {
			if (strict.not and: { plug.isKindOf(VoxPlug) }) {
				var tempVox = Vox.fromPlug(plug);
				voxes[tempVox.label] = tempVox;
				label = tempVox.label;
				metadata = tempVox.metadata;
				metremap = tempVox.metremap;
				tpqn = metremap.tpqn;

				voxes.notEmpty.if {
					voxes.values.do({
						arg vox, i;
						vox.parentVoxMulti = this;
						vox.calculatePositions;
					})
				};

				this.highlightAll;
				this.commit;
				^this
			};

			if (strict.not and: { plug.isKindOf(VoxPlugMulti) }) {
				var tempVox = VoxMulti.fromPlugMulti(plug, plug.label);
				voxes = tempVox.voxes;
				label = tempVox.label;
				metadata = tempVox.metadata;
				metremap = tempVox.metremap;
				tpqn = metremap.tpqn;

				voxes.notEmpty.if {
					voxes.values.do({
						arg vox, i;
						vox.parentVoxMulti = this;
						vox.calculatePositions;
					})
				};

				this.highlightAll;
				this.commit;
				^this
			};

			"😬 VoxMulti(%).load: No match found, cannot load to empty VoxMulti in strict mode."
			.format(this.label).warn;
			^this
		};

		if (plug.isKindOf(VoxPlug)) {
			strict.if {
				var match = voxes[plug.label];
				match.notNil.if {
					match.load(plug);
					if (range.isNil or: { this.duration == 0 }) {
						this.highlightAll
					};
					this.commit;
					^this
				} {
					"😬 VoxMulti(%).load: No matching Vox found for label %"
					.format(this.label, plug.label).warn;
					^this
				}
			};

			voxes.values.first.load(plug);
			if (range.isNil or: { this.duration == 0 }) {
				this.highlightAll
			};
			this.commit;
			^this
		};

		// if strict and PlugMulti
		if (strict and: { plug.isKindOf(VoxPlugMulti) }) {
			plug.plugs.do { |inputPlug|
				var target = voxes[inputPlug.label];
				if (target.notNil) {
					target.load(inputPlug);
					// I guess if these are loaded to empty Voxes,
					// those Vox ranges can't be updated ??
				} {
					"😬 VoxMulti(%): No match for plug label %"
					.format(this.label, inputPlug.label).warn;
				}
			};
			if (range.isNil or: { this.duration == 0 }) {
				this.highlightAll;
				range.postln; // HERE IS A PROBLEM NOT SETTING RANGE WITH NEW EVENTS
			};
			this.commit;
			^this;
		};

		// if not strict and PlugMulti
		if (strict.not and: { plug.isKindOf(VoxPlugMulti) }) {
			var limit;

			limit = [plug.size, voxes.size].minItem;

			"limit is: %".format(limit).postln;
			"plug size is: %".format(plug.size).postln;
			"voxes size is: %".format(voxes.size).postln;

			"plugs are: %".format(plug.plugs).postln;

			limit.do({
				arg i;
				var vox_vals = voxes.values;
				var plug_vals = plug.plugs.values;

				vox_vals[i].forceload(plug_vals[i]);
			});

			if (range.isNil or: { this.duration == 0 }) {
				this.highlightAll
			};
			this.commit;
			^this
		};

		// Catch-all fallback
		"😬 VoxMulti(%).load: Unrecognized source type %"
		.format(this.label, plug.class).warn;
		^this
	}

	forceload { |source|
		this.load(source, false);
		if (range.isNil or: { this.duration == 0 }) {
			this.highlightAll;
		};
		^this
	}

	loadFromDict { |voxesDict, metremapArg, labelArg|
		if (voxesDict.isNil or: { voxesDict.isEmpty }) {
			"❌ VoxMulti.loadFromDict: no voxes provided".warn;
			^this
		};

		^this.forceload(VoxMulti.fromDict(voxesDict, metremapArg, labelArg));
	}

	commit { |label = nil|
		history.commit(this.out, label);
	}

	undo {
		this.input = history.undo.plug;
	}

	redo {
		this.input = history.redo.plug;
	}

	out {
		var plugs = voxes.values.collect(_.out);
		^VoxPlugMulti.new(plugs)
	}
}
VoxHistory {
	var <history, <pointer;

    *new { ^super.new.init }

    init {
        history = List.new;
        pointer = -1;
        ^this
    }

	log {
		history.do({ |entry, i|
			" ------------ version % ------------".format(i).postln;
			"%: %".format(entry.label, entry.time).postln;
		});
	}

    commit { |voxplug, label=nil|
        // Trim any undone future
        if (pointer < (history.size - 1)) {
            history = history.copyRange(0, pointer);
        };

        history.add((plug: voxplug.deepCopy, label: label, time: Date.getDate));
        pointer = history.size - 1;
    }

    undo {
        if (pointer > 0) { pointer = pointer - 1 };
        ^history[pointer]
    }

    redo {
        if (pointer < (history.size - 1)) { pointer = pointer + 1 };
        ^history[pointer]
    }

    current { ^history[pointer] }
}
VoxProxy : VoxNode {
    var <key, <transform;

    *new { |key, transform|
        ^super.new.init(key, transform)
    }

    init { |k, t|
        key = k;
        transform = t;  // optional function: Vox → Vox
        ^this
    }

    out {
        var plug = this.input.notNil.if {
            this.input.out[key]
        } {
            "VoxBuilder: no input set".warn;
			nil;
        };

        plug.notNil.if {
            transform.notNil.if {
                ^VoxPlug.new(
                    transform.value(plug),
                    plug.label,
                    plug.origin
                )
            } {
                ^plug
            }
        }
    }
}

VoxRouter : VoxNode {
    var <routes, <allowFallback = true;

    *new { |source|
        ^super.new.init(source)
    }

    init { |sourceNode|
        routes = IdentityDictionary.new;
        input = sourceNode;
        ^this
    }

    add { |spec|
		var key, chain, proxy;

		if (spec.isKindOf(Symbol)) {
			key = spec;
			proxy = VoxProxy.new(key);
			chain = proxy;
		} {
			key = spec.sourceKey;
			chain = spec.chain;

			// Create a VoxBuilder for the key
			proxy = VoxProxy.new(key);

			// Wire it into the first node in the chain
			proxy >>> chain.headNode;  // Must define or require `.headNode`
		};

		// Wire input into the builder (so it extracts the correct voice)
		input >>> proxy;

		// Store the final chain output
		routes[key] = chain;
	}

    addFromUpstream { |keys|
        keys.do { |key|
            this.add(key);
        }
    }

    out {
        var sourceOut = input.out;
        var plugs = [];

        // Get union of routed + source keys
        var allKeys = routes.keys ++ sourceOut.keys;
        allKeys.do { |key|
            var route = routes[key];
			var plug;

			route.postln;

			route.notNil.if {
				plug = route.out
			};

            if (route.isNil and: { allowFallback }) {
                plug = sourceOut[key];
            };

            if (plug.notNil) {
                plugs = plugs.add(plug);
            };
        };

		plugs.postln;

        ^VoxPlugMulti.new(plugs, sourceOut.metremap, sourceOut.label);
    }
}

// VoxArrangement {
// var <>metremap;
// var <>tpqn;
// var timelineDict;  // Dict of trackLabel -> List[ {start, vox, metadata} ]
//
// *new { |metremap|
// ^super.new.init(metremap)
// }
//
// init { |metremap|
// this.metremap = metremap;
// this.tpqn = metremap.tpqn;
// timelineDict = Dictionary.new;
// }
//
// addToTrack { |trackLabel, vox, startPos, metadata = ()|
// var entry = (
// start: startPos,
// vox: vox,
// metadata: metadata
// );
//
// timelineDict[trackLabel] = timelineDict[trackLabel] ?? { List.new };
// timelineDict[trackLabel].add(entry);
// }
//
// flatten {  // Collect everything into a single VoxMulti
// var allVoxes = [];
//
// timelineDict.do { |label, events|
// events.do { |entry|
// var shifted = entry[\vox].copyWithShift(entry[\start], metremap);
// shifted.metadata = shifted.metadata.put(\trackLabel, label);
// allVoxes = allVoxes.add(shifted);
// }
// };
//
// ^VoxMulti.new(allVoxes, metremap, \flattened);
// }
//
// /*asMIDI { |path|
// this.flatten().asMIDIFile(path);  // You’d need to define `asMIDIFile` on VoxMulti
// }*/
// }
///////////////////////////////////
// Time Conversion Utility Class //
///////////////////////////////////
TimeConverter {
	// posToTicksMetre
	*posToTicksMetre {|pos, metre|
		var
		bars = metre.barsToTicks(pos.bar),
		beats = metre.beatsToTicks(pos.beat),
		divisions = metre.divisionsToTicks(pos.division, pos.beat);

		^[bars, beats, divisions, pos.tick].sum
	}

	// ticksToPosMetre
	*ticksToPosMetre {|ticks, metre|
		var bar, remainder, beat, division, tick;
		var barsResult, beatsResult, divisionsResult;

		barsResult = metre.ticksToBars(ticks);
		bar = barsResult.bars;
		remainder = barsResult.ticks;

		beatsResult = metre.ticksToBeats(remainder);
		beat = beatsResult.beats;
		remainder = beatsResult.ticks;

		divisionsResult = metre.ticksToDivisions(remainder, beat);
		division = divisionsResult.divisions;
		tick = divisionsResult.ticks;

		^Pos(bar, beat, division, tick)
	}

	*posToTicks {|pos, metremap|
		var
		beats = metremap.barsToBeats(pos.bar) + pos.beat,
		divs = metremap.beatsToDivisions(beats) + pos.division;

		^metremap.divisionsToTicks(divs) + pos.tick
	}

	*ticksToPos {|ticks, metremap|
		var
		barInfo = metremap.ticksToBars(ticks),
		bars, ticksLeft, metre,
		beats = 0, divisions = 0, finalTicks = 0,
		ticksPerBeat, divisionsPerBeat,
		divSize,
		i = 0;

		if (barInfo.isNil) { ^nil };

		bars = barInfo.bars;
		ticksLeft = barInfo.ticks;
		metre = metremap.whichRegion(ticks).metre;

		ticksPerBeat = metre.ticksPerBeat;
		divisionsPerBeat = metre.divisionsPerBeat;

		// Resolve into beats
		while { ticksLeft >= ticksPerBeat.wrapAt(i) } {
			ticksLeft = ticksLeft - ticksPerBeat.wrapAt(i);
			beats = beats + 1;
			i = i + 1;
		};

		// Resolve into divisions
		divSize = (ticksPerBeat.wrapAt(i) / divisionsPerBeat.wrapAt(i)).asInteger;
		divisions = ticksLeft div: divSize;
		finalTicks = ticksLeft % divSize;

		^Pos(bars, beats, divisions, finalTicks)
	}

	*normaliseMetre {
		arg pos, metre;

		var totalTicks = this.posToTicksMetre(pos, metre);

		^this.ticksToPosMetre(totalTicks, metre)
	}

	*normalise {
		arg pos, metremap;

		var totalTicks = this.posToTicks(pos, metremap);

		^this.ticksToPos(totalTicks, metremap)
	}

	// needs another look, could be made simpler?
	*midiTimeSigToMetre { |sigArray, tpqn, preferCompound=true, grouping=nil|
		var nn, dd, cc, bb;
		var baseDur, beats, divisions;

		#nn, dd, cc, bb = sigArray;

		baseDur = 1 / (2 ** dd);  // e.g. 1/8 = 0.5 quarter notes

		if (grouping.notNil) {
			// e.g. grouping = [3,2,2] (implied eighths)
			beats = grouping.collect { |g| (baseDur * g) * 4 };
			divisions = grouping.collect { |g| g * 2 };  // 2 divisions per eighth
		} {
			if (preferCompound and: { (nn % 3 == 0) and: (nn > 3) }) {
				var groupCount = nn / 3;
				var beatDur = (baseDur * 3) * 4;
				beats = Array.fill(groupCount, { beatDur });
				divisions = Array.fill(groupCount, { 6 });
			} {
				beats = Array.fill(nn, { baseDur * 4 });
				divisions = Array.fill(nn, { 4 });
			}
		};

		^Metre.new(beats, divisions, tpqn);
	}
}
VoxPatcher {
    var <branches;

    *new { |branchesDict|
        ^super.new.init(branchesDict)
    }

    init { |branchesDict|
        branches = branchesDict;
        ^this
    }

    at { |key| ^branches[key] }
	keys { ^branches.keys }
    asDict { ^branches.copy }
}

VoxRoute {
	var <sourceKey, <chain;

	*new { |sourceKey, chain|
		^super.newCopyArgs(sourceKey, chain)
	}
}
/////////////////////////////////////////////////////
// Player Wrapper Class: for synth & MIDI playback //
/////////////////////////////////////////////////////
VoxPlayer {
	var source, clock, task;

	*new {
		arg source, clock;

		^super.newCopyArgs(source, clock)
	}

	stop {
		if (task.notNil) { task.stop };
	}

	start {
		if (task.notNil) { task.start }
	}

	pause {
		if (task.notNil) { task.pause }
	}

	////////////////////
	// SYNTH PLAYBACK //
	////////////////////
	play {|quant|
		task = this.makeTask;
		task.play(quant: quant);
	}

	loop {|quant|
		task = this.makeLoop;
		task.play(quant: quant);
	}

	makeTask { |instrument = \default|

		if (clock.isNil) {clock = TempoClock.default };

		^Task ({
			var plug = source.respondsTo(\out).if { source.out } { source };
			var events = plug.events;
			var startTick = events.first[\absTime];
			var tpqn = plug.metremap.tpqn;

			events.do({ |event|
				{
					var deltaBeats = (event[\absTime] - startTick).toMIDIBeats(tpqn);
					var durBeats = event[\dur].toMIDIBeats(tpqn);
					var synth;

					deltaBeats.wait;
					synth = Synth(instrument, [\freq, event[\midinote].midicps]);
					durBeats.wait;
					synth.release(1.5);

				}.fork(clock);
			})
		})
	}

	makeLoop { |instrument = \default|

		if (clock.isNil) {clock = TempoClock.default };

		^Task ({
			loop {
				var plug = source.respondsTo(\out).if { source.out } { source };
				var events = plug.events;
				var startTick = events.first[\absTime];
				var lastEvent, clipEnd, totalTicks, totalBeats;
				var tpqn = plug.metremap.tpqn;

				events.do({ |event|
					{
						var deltaBeats = (event[\absTime] - startTick).toMIDIBeats(tpqn);
						var durBeats = event[\dur].toMIDIBeats(tpqn);
						var synth;

						deltaBeats.wait;
						synth = Synth(instrument, [\freq, event[\midinote].midicps]);
						durBeats.wait;
						synth.release(1.5);

					}.fork(clock);
				});

				// Wait for the full clip duration before restarting
				lastEvent = events.last;
				clipEnd = lastEvent[\absTime] + lastEvent[\dur];
				totalTicks = clipEnd - startTick;

				totalTicks.toMIDIBeats(tpqn).wait;
			};
		}, clock)
	}


	///////////////////
	// MIDI PLAYBACK //
	///////////////////
	playMIDI { |midiout, quant|
		var plug = source.respondsTo(\out).if { source.out } { source };

		if (plug.isKindOf(VoxPlugMulti)) {
			task = this.makeMIDITaskMulti(midiout);
		} {
			task = this.makeMIDITask(midiout);
		};

		task.play(quant: quant);
	} // play once as midi

	loopMIDI {|midiout, quant|
		var plug = source.respondsTo(\out).if { source.out } { source };

		if (plug.isKindOf(VoxPlugMulti)) {
			task = this.makeMIDILoopMulti(midiout);
		} {
			task = this.makeMIDILoop(midiout);
		};

		task.play(quant: quant);
	} // play loop as midi

	makeMIDITask { |midiout|

		if (clock.isNil) { clock = TempoClock.default };

		^Task ({

			var plug = source.respondsTo(\out).if { source.out } { source };
			var events = plug.events;
			var startTick = events.first[\absTime];
			var tpqn = plug.metremap.tpqn;

			events.do { |event|
				{
					var deltaBeats = (event[\absTime] - startTick).toMIDIBeats(tpqn);
					var durBeats = event[\dur].toMIDIBeats(tpqn);

					deltaBeats.wait;

					midiout.noteOn(event.channel, event.midinote, event.velocity);

					durBeats.wait;

					midiout.noteOff(event.channel, event.midinote, event.velocity);
				}.fork(clock);
			}
		}, clock);
	}

	makeMIDITaskMulti { |midiout|
		if (clock.isNil) { clock = TempoClock.default };

		^Task({
			var plug = source.respondsTo(\out).if { source.out } { source };
			var plugs = plug.asArray;
			var globalStartTick = plugs.collect { |p| p.events.first[\absTime] }.minItem;
			var tpqn = plug.metremap.tpqn;

			plugs.do { |p, i|
				var channel = i.clip(0, 15);
				var events = p.events;

				events.do { |event, j|
					{
						var deltaBeats = (event[\absTime] - globalStartTick).toMIDIBeats(tpqn);
						var durBeats = event[\dur].toMIDIBeats(tpqn);

						deltaBeats.wait;
						midiout.noteOn(channel, event[\midinote], event[\velocity]);
						durBeats.wait;
						midiout.noteOff(channel, event[\midinote], event[\velocity]);

					}.fork(clock);
				};
			};
		}, clock);
	}


	makeMIDILoop { |midiout|
		if (clock.isNil) { clock = TempoClock.default };

		^Task ({
			loop {
				var plug = source.respondsTo(\out).if { source.out } { source };
				var events = plug.events; // get updated event list
				var startTick = events.first[\absTime]; // absolute start of clip
				var lastEvent, clipEnd, totalTicks, totalBeats;
				var tpqn = plug.metremap.tpqn;

				// Schedule each event individually with correct offset
				events.do { |event|
					{
						var deltaBeats = (event[\absTime] - startTick).toMIDIBeats(tpqn);
						var durBeats = event[\dur].toMIDIBeats(tpqn);

						deltaBeats.wait;

						midiout.noteOn(event.channel, event.midinote, event.velocity);

						durBeats.wait;

						midiout.noteOff(event.channel, event.midinote, event.velocity);

					}.fork(clock);
				};

				// Wait for the full clip duration before restarting
				lastEvent = events.last;
				clipEnd = lastEvent[\absTime] + lastEvent[\dur];
				totalTicks = clipEnd - startTick;

				totalTicks.toMIDIBeats(tpqn).wait;
			}
		}, clock);


	}

	makeMIDILoopMulti { |midiout|
		if (clock.isNil) { clock = TempoClock.default };

		^Task ({
			loop {
				var plug = source.respondsTo(\out).if { source.out } { source };
				var plugs = plug.asArray;
				var globalStartTick = plugs.collect { |p| p.events.first[\absTime] }.minItem;
				var clipEnd, totalTicks;
				var tpqn = plug.metremap.tpqn;

				plugs.do { |p, i|
					var channel = i.clip(0, 15);
					var events = p.events;

					events.do { |event, j|
						{
							var deltaBeats = (event[\absTime] - globalStartTick).toMIDIBeats(tpqn);
							var durBeats = event[\dur].toMIDIBeats(tpqn);

							deltaBeats.wait;
							midiout.noteOn(channel, event[\midinote], event[\velocity]);
							durBeats.wait;
							midiout.noteOff(channel, event[\midinote], event[\velocity]);

						}.fork(clock);
					};
				};

				// Wait for the full clip duration before restarting
				clipEnd = plugs.collect({ |p| var last = p.events.last; last[\absTime] + last[\dur] }).maxItem;
				totalTicks = clipEnd - globalStartTick;

				totalTicks.toMIDIBeats(tpqn).wait;
			}
		}, clock);
	}
}
VoxPlug {
	var <events, <metremap, <label, <metadata, <>source;

	*new {
		arg events, metremap, label, metadata, source;

		^super.new.init(events, metremap, label, metadata, source);
	}

	init {
		arg eventsArg, metremapArg, labelArg, metadataArg, sourceArg;

		events = eventsArg.deepCopy ? [];
		metremap = metremapArg.deepCopy ? MetreMap.new;
		label = labelArg.copy ? \anonyPlug;
		metadata = metadataArg.deepCopy ? Dictionary.new;

		// ensure metremap has a metre
		metremap.isEmpty.if {
			metremap.add(MetreRegion(0, Metre([1, 1, 1, 1], [4, 4, 4, 4])));
		};

		source = sourceArg;

		^this
	}

	copy {
		^VoxPlug.new(events.deepCopy, metremap.deepCopy, label.copy, metadata.deepCopy, source);
	}
}

VoxPlugMulti {
    var <plugs, <metremap, <label, <metadata, <>source;

    *new {
		arg plugs, metremap, label, metadata, source;

        ^super.new.init(plugs, metremap, label, metadata, source);
    }

	init { |plugsArg, metremapArg, labelArg, metadataArg, sourceArg|

		plugsArg.notNil.if {
			var labels;
			labels = plugsArg.collect(_.label);
			plugs = Dictionary.newFrom([labels, plugsArg].lace);
		} {
			plugs = Dictionary.new;
		};

		metremap = metremapArg ? MetreMap.new;
		label = labelArg ? \anonyPlugMulti;
		metadata = metadataArg ? Dictionary.new;

		// ensure metremap has a metre
		metremap.isEmpty.if {
			metremap.add(MetreRegion(0, Metre([1, 1, 1, 1], [4, 4, 4, 4])));
		};

		source = sourceArg;

		^this
	}

	*fromDict {
		arg plugsDict, metremap, label, metadata, source;

		^super.new.initFromDict(plugsDict, metremap, label, metadata, source)
	}

	initFromDict {
		arg plugsDictArg, metremapArg, labelArg, metadataArg, sourceArg;

		plugs = plugsDictArg ? Dictionary.new;
		metremap = metremapArg ? MetreMap.new;
		label = labelArg ? \anonyPlugMulti;
		metadata = metadataArg ? Dictionary.new;

		// ensure metremap has a metre
		metremap.isEmpty.if {
			metremap.add(MetreRegion(0, Metre([1, 1, 1, 1], [4, 4, 4, 4])));
		};

		source = sourceArg;

		^this
	}

	// SO THE ID CHECK IS POINTLESS NOW
    at { |key|
		if (key.isInteger) {
			var plug = plugs.values.detect { |p| p.source.id == key };
			if (plug.notNil) {
				^plug
			} {
				"❌ No plug found with index ID %".format(key).warn;
				^nil
			}
		} {
			var plug = plugs[key];
			if (plug.notNil) {
				^plug
			}{
				"❌ No plug found with label %".format(key).warn;
				^nil
			};
		}
    }

    size {
        ^plugs.size
    }

    do { |func|
        this.asArray.do(func);
    }

    asArray {
		// I think this can just be plugs.values;
        ^plugs.values;
    }

	keys {
		^plugs.keys
	}
}
VoxModule : VoxNode {
	var <>active = true;

	*new { |label|
		^super.new.init(label)
	}

	init { |labelArg|
		label = labelArg ? this.class.asSymbol;
		metadata = Dictionary.new;
		^this
	}

	input_ { |source|
		("✅ Input set on %: source = %".format(this.label ? this.class, source.class)).postln;
		input = source;
	}

	// checks if active (basic filter)
	// processes plug, returns vox
	process { |plug|
		^active.if {
			this.doProcess(plug);
		} {
			plug;
		}
	}

	// Must return a VoxPlug
	doProcess { |plug|
		"😬 VoxModule subclass must implement doProcess".warn;
		^plug; // return same plug if no process implemented
	}

	// takes VoxPlugMulti
	// Applies single process to each plug in turn
	// Implement on module if anything changes in multiProcess
	// Must return VoxPlugMulti
	doMultiProcess { |plugMulti|

		var plugs = plugMulti.plugs.values.collect { |plug|
			var processed;

			processed = this.process(plug);

			if (processed.isKindOf(VoxPlug).not) {
				plug; // return the unprocessed plug
			} {
				processed
			}
		};

		^VoxPlugMulti.new(plugs, plugMulti.metremap, plugMulti.label, plugMulti.metadata, this); // TO DO: I think this works????
	}

	// implement on module, must return VoxPlugMulti
	doMultiOutput { |plug|
		^nil;  // default: no multi-output
	}

	// Implement on module
	// Not exactly sure what this does at the moment
	// VoxMulti in, VoxMulti or Vox out?
	// Must return VoxPlug or VoxPlugMulti
	doMerge { |plugs|
		^nil;
	}

	out {
		var plug;
		var multiOut, processOutput;

		plug = input.respondsTo(\out).if {
			input.out
		} {
			input // assumes input is plug, but ideally not
		};

		if (plug.isNil or: { plug.isKindOf(VoxPlug).not && plug.isKindOf(VoxPlugMulti).not }) {
			"😬 VoxModule input is not compatible, not connected or does not support .out".warn;
			// returns single empty plug as default
			^VoxPlug.new;
		};

		// Case 1: VoxMulti in, VoxMulti out
		if (plug.isKindOf(VoxPlugMulti)) {
			// Check if subclass wants to merge
			// CHECK THIS LATER
			var merged = this.doMerge(plug.asArray);
			if (merged.notNil) { ^merged; };
			// Otherwise, process each individually
			^this.doMultiProcess(plug); // returns PlugMulti
		};

		// Case 2: Vox in, VoxMulti out
		// All doMultiOutput
		multiOut = this.doMultiOutput(plug);
		if (multiOut.notNil) {
			multiOut.isKindOf(VoxPlugMulti).if {
				^multiOut; // just return output from module
			} {
				"VoxModule(%): expected VoxPlugMulti, got %".format(this.label, multiOut).warn;
				^VoxPlugMulti.new; // default return expected PlugMulti, empty
			}
		};

		// Case 3: vox in, vox out
		processOutput = this.process(plug);

		// this.process should return a VoxPlug
		if (processOutput.isKindOf(VoxPlug)) {
			^processOutput;
		};

		// in case it doesn't, yield empty plug
		"VoxModule(%): expected VoxPlug, got % - returning empty VoxPlug"
		.format(this.label, processOutput).warn;

		^VoxPlug.new;
	}
}
VoxNode {
	var <input, <>label, <>metadata;

	input_ { |node|
		input = node;
		^this
	}

	headNode {
		var node = this;

		while {
			node.input.notNil and: { node.input.isKindOf(VoxNode) }
		} {
			node = node.input;
		};

		^node;
	}

	out {
		if (input.notNil) {
			^input.out
		} {
			^nil
		}
	}

	>>> { |target|

		target.isKindOf(VoxNode).if {
			target.input = this;
		} {
			"❌ Cannot patch: Only VoxNodes may be chained using >>>. Got % >>> %."
			.format(this.class, target.class).warn;
		};

		^target;
	}

	>>= { |target|

		if (target.isKindOf(Symbol)) {
			target.envirPut(this);
			^this
		};

		if (target.isKindOf(Vox) or: { target.isKindOf(VoxMulti) }) {
			target.load(this);
			^target
		};

		"❌ Cannot patch: >>= can only patch to Symbol, Vox or VoxMulti. Got % >>= %."
		.format(this.class, target.class).warn;
		^target
	}

	>>==> { |target|
		target.forceload(this);
		^target
	}

	<<< { |target|

		if (target.isKindOf(VoxNode)) {
			target.headNode.input = this;
		} {
			"❌ Cannot patch: Only VoxNodes may be chained using <<<. Got % <<< %."
			.format(this.class, target.class).warn;
		}

		^target
	}

	>>< { |spec|
		this.split(spec);
	}

	split { |spec|
		var
		multiPlug = this.out,
		named = Dictionary.new,
		specDict = spec.isKindOf(Array).if {
			spec.asDict;
		} {
			spec;
		};

		// this assumes array will be [\name, []]

		if (multiPlug.isKindOf(VoxPlugMulti).not) {
			"❌ Cannot split %: expected VoxPlugMulti.".format(multiPlug.class).warn;
			^this
		};

		specDict.keysValuesDo { |key, voxID|
			// check if array of voxes
			var selected = voxID.isArray.not.if
			{
				multiPlug.at(voxID);
			} {
				voxID.collect { |id| multiPlug.at(id) };
			};

			named[key] = (selected.isArray.not).if { selected } { VoxMulti.new(selected) };
		};

		^VoxPatcher.new(named);
	}

	// THIS IS SUPER TRICKSOME
	// Now needs to output VoxRouter I think ...
	/*>>@ { |routes|
		var basePlug = this.out;
		var processed = [];

		routes.do { |route|
			if (route.isKindOf(VoxRoute)) {
				var source = basePlug.at(route.sourceKey);

				if (source.isNil) {
					"❌ Could not find source for key % in >>@".format(route.sourceKey).warn;
				} {
					// COME BACK HERE ... work out
					source.source <<< route.chain;
					processed = processed.add(route.chain);
				};
			} {
				"❌ Expected VoxRoute in >>@ list, got %".format(route.class).warn;
			};
		};

		^VoxMulti.fromPlugMulti(VoxPlugMulti.new(processed.collect(_.out)));
	}*/

	>>@ { |routes|
		var router = VoxRouter.new(this);
		routes.do(router.add(_));
		^router
	}

	>>* { |key|
		var plug = this.out;

		if (plug.isKindOf(VoxPlugMulti)) {
			^plug.at(key).source;
		};

		"❌ Expected VoxPlugMulti for selector >>*, got %"
		.format(this.class).warn;
		^this
	}

	>>/ { |range|
		var plug = this.out;

		if (plug.isKindOf(VoxPlug)) {
			plug.source.highlight(range[0], range[1]);
			^plug.source.clip;
		};

		if (plug.isKindOf(VoxPlugMulti)) {
			^VoxMulti.fromPlugMulti(plug).clip(range);
		};

		"❌ Cannot clip from %, expected VoxPlug or VoxPlugMulti."
		.format(plug.class).warn;

		^this
	}

	// merges VoxNode out (VoxPlug or VoxPlugMulti) into a Vox or VoxMulti
	>>+ { |spec|
		this.add(spec)
		^this;
	}

	>>+= { |target|
		// implement: not sure what it should do
		// I think this is merge and assign to symbol...?
		// mutates target?
	}

	>>& { |vox|
		// IMPLEMENT METHOD ON VOX (CONSIDER VOXMULTI SITUATION)
		// this will be able to load empty Vox with events from Pbind e.g.
		vox.loadFromEvents(this);
		^vox
	}
}




VoxTransposer : VoxModule {
	var <>semitones;

	*new { |semitones = 0|
		^super.new.initTranspose(semitones);
	}

	initTranspose { |semitones|
		this.semitones = semitones;
		^this
	}

	doProcess { |plug|
		var events = plug.events.collect { |ev|
			var newEv = ev.copy;
			newEv[\midinote] = ev[\midinote] + semitones;
			newEv
		};

		^VoxPlug.new(
			events,
			plug.metremap,
			plug.label,
			plug.metadata.copy
		)
	}
}


VoxCanoniser : VoxModule {
	var <>numVoices, <>namesToOffsetsDict;

	*new { |numVoices = 3, voxNames, entryOffsets, label = "Anon_Canon"|
		^super.new(label).initCanon(numVoices, voxNames, entryOffsets);
	}

	initCanon { |numVoicesArg, voxNamesArg, entryOffsetsArg, labelArg|
		var voxnames, offsets;

		numVoices = numVoicesArg;
		voxnames = voxNamesArg ?? this.getNames(numVoicesArg);
		offsets = entryOffsetsArg ?? Array.fill(numVoicesArg, { |i| Pos(0, i * 2) });

		if (voxnames.size != offsets.size) {
			"😬 VoxCanoniser: Mismatch between voice names and entry offsets.".warn;
		};
		namesToOffsetsDict = [voxnames, offsets].lace.asDict;

		^this
	}

	getNames { |nv|
		var namesArr = Array.new(nv);
		nv.do({ |i| namesArr.add("%_vox-%".format(this.label, i)) });
		^namesArr
	}

	// change how this accesses voices ...
	doMultiOutput { |plug|
		var events = plug.events;
		var map = plug.metremap;
		var plugDict = Dictionary.new;

		// I want to take each of namesToOffsets and
		// do process of shifting absTime on each event
		//
		namesToOffsetsDict.keys.do({
			arg key;
			var offsetPos = namesToOffsetsDict[key];
			var offsetTicks = TimeConverter.posToTicks(offsetPos, map);

			var shifted = events.collect({
				arg ev;
				var newAbsTime = ev[\absTime] + offsetTicks;
				ev.copy.putAll([
					\absTime: newAbsTime,
					\position: TimeConverter.ticksToPos(newAbsTime, map)
				]);
			});

			var vox = Vox.new(shifted, map, key);
			var voxPlug = vox.out;

			plugDict[key] = voxPlug;
		});

		^VoxPlugMulti.fromDict(plugDict, map, label, source: this);
	}
}
+ Metre {
	////////////////////////
	// CONVERSION HELPERS //
	////////////////////////
	ticksPerBar {
		^this.ticksPerBeat.sum.asInteger
    }

	ticksPerBeat {
		^beats.collect({ |beat| (beat * tpqn).round.asInteger })
	}

	ticksPerDivision {
		^beats.collect({
			arg beat, i;
			var beatTicks = (beat * tpqn).round.asInteger;
			(beatTicks / divisions[i]).round.asInteger
		})
    }

	divisionsPerBar {
		^divisions.sum.asInteger
	}

	divisionsPerBeat {
		^divisions.copy
	}

	allDivisionTicks {
		var ticksPerDivision = this.ticksPerDivision;
		^divisions.collect({|divs, i| ticksPerDivision[i].dup(divs) }).flat;
	}

	beatsPerBar {
		^beats.size
	}

	whichBeat {|ticks|
		var beats = this.ticksToBeats(ticks).beats;
		^beats % this.beatsPerBar;
	}

	// to ticks
	barsToTicks {|bars|
		^(bars * this.ticksPerBar).round.asInteger
	}

	// allow float output in case of fractional bars input
	barsToBeats {|bars|
		^bars * this.beatsPerBar
	}

	beatsToTicks {|numBeats, offset=0|

		var
		fullBeats = numBeats.floor.asInteger,
		partial = numBeats - fullBeats,
		ticksPerBeat = this.ticksPerBeat;

		var fullTicks = fullBeats.collect({ |i|
			ticksPerBeat.wrapAt(i + offset)
		}).sum; // will always be integer

		// round and cast as integer to force integer output
		var partialTicks = (partial * ticksPerBeat.wrapAt(fullBeats + offset)).round.asInteger;

		^fullTicks + partialTicks
	}

	beatsToDivisions {|numBeats, offset=0|

		var
		fullBeats = numBeats.floor.asInteger,
		partial = numBeats - fullBeats,
		ticksPerBeat = this.ticksPerBeat;

		var fullDivisions = fullBeats.collect({ |i|
			divisions.wrapAt(i + offset)
		}).sum;

		var partialDivisions = (partial * divisions.wrapAt(fullBeats + offset)).round.asInteger;

		^fullDivisions + partialDivisions
	}

	divisionsToTicks {|divs, beatOffset=0|
		var
		ticksPerDivision = this.ticksPerDivision,
		allDivisionTicks = this.allDivisionTicks,
		// ensure beatOffset is valid integer index
		beatOffsetInt = beatOffset.floor.asInteger,
		divisionOffset = beatOffsetInt.collect{arg i; this.divisions.wrapAt(i)}.sum;

		if (divs.isInteger.not) {
			("Invalid input [%]: divs must be positive integer".format(divs)).throw;
		}

		^divs.collect({|division| allDivisionTicks.wrapAt(division + divisionOffset)}).sum
	}

	// from ticks
	ticksToBars {|ticks|
		var ticksPerBar = this.ticksPerBar;
		^(bars: ticks div: ticksPerBar, ticks: (ticks % ticksPerBar).round.asInteger)
	}

	ticksToBeats {|totalTicks|
		var
		remainingTicks = totalTicks.round.asInteger,
		ticksPerBeat = this.ticksPerBeat,
		i = 0,
		counter = 0;

		// it would be easier if this accepted a beat offset ...
		// this starts on beat 1

		while { (remainingTicks - ticksPerBeat.wrapAt(i)).isNegative.not } {
			remainingTicks = remainingTicks - ticksPerBeat.wrapAt(i);
			counter = counter + 1;
			i = i + 1;
		};

		^(beats: counter, ticks: remainingTicks.round.asInteger)
	}

	ticksToDivisions {|totalTicks, beatOffset=0|
		var
		remainingTicks = totalTicks.round.asInteger,
		count = 0,
		allDivisionTicks = this.allDivisionTicks,
		// whatever beat offset index is, collect lots of divisions up to that index and sum
		divisionOffset = beatOffset.collect{arg i; divisions[i]}.sum;

		loop {
			allDivisionTicks.size.do({ // all individual numbers of ticks per division for full bar
				arg i;
				var ticks = allDivisionTicks.wrapAt(i + divisionOffset);

				if (remainingTicks >= ticks) { // if enough ticks
					remainingTicks = remainingTicks - ticks;
					count = count + 1;
				} { ^(divisions: count, ticks: remainingTicks) }
			})
		}
	}

	// other helpers
	lastBarline {|tick|
		tick = tick.round.asInteger;
		^tick - (tick % this.ticksPerBar)
	}

	nextBarline {|tick|
		var ticksPerBar = this.ticksPerBar;
		var rem;

		tick = tick.round.asInteger;
		rem = tick % ticksPerBar;

		if (rem == 0) { ^tick };

		^tick + (ticksPerBar - rem)
	}

	nearestBarline {|tick|
		var ticksPerBar = this.ticksPerBar;
		var rem, diff;

		tick = tick.round.asInteger;

		rem = tick % ticksPerBar;

		if (rem == 0) { ^tick };

		diff = ticksPerBar - rem;
		if (diff < rem) { ^tick + diff } { ^tick - rem }
	}
}
+ MetreRegion {

	bars {
		var regionTicks = this.metre.regionSize(this);

		^this.metre.ticksToBars(regionTicks)
	}

	shift {
		arg inval;

		^MetreRegion(this.start + inval, this.metre);
	}

	== {
		arg other;

		var startEquality = this.start == other.start;
		var metreEquality = this.metre == other.metre;

		if (other.isKindOf(MetreRegion).not) { ^false }

		^(startEquality && metreEquality)
	}

	< {|other|
		^this.start < other.start
	}

	> {|other|
		^this.start > other.start
	}
}


+ Symbol {

	<<< { |chain|
		^VoxRoute.new(this, chain);
	}

}

+ Integer {

	<<< { |chain|
		^VoxRoute.new(this.chain);
	}

}

// I think might need a better connection design, to keep track of flow of parts, just an ordering system for voices ... sort by their voiceID or something ... 

+ MetreMap {

	matching {|region|
		^this.regionIndex(region).notNil
	}

	pushDownstream {|region|
		var downstream, nextBarline, offset;

		downstream = regions.select({arg reg; reg.start > region.start});

		if (downstream.isEmpty.not) {
			var firstDown = downstream[0];
			nextBarline = region.metre.nextBarline(firstDown.start - region.start);
			offset = (nextBarline + region.start) - firstDown.start;

			// Shift and replace downstream entries
			downstream.do { |reg|
				var idx = regions.indexOf(reg);
				if (idx.notNil) {
					regions.put(idx, reg.shift(offset));
				}
			};
		};
	}

	sortEntries {
		regions.sort({ arg a, b; a.start < b.start })
	}

	whichRegion {|tickVal|
		^regions
		  .select({|entry| entry.start <= tickVal })
		  .sort({ |a, b| a.start < b.start })
		  .last;
	}

	regionIndex {|inRegion|
		^regions.detectIndex({ arg region; region == inRegion });
	}

	indexFromTicks {|tickVal|
		^this.regionIndex(this.whichRegion(tickVal));
	}

	insertionIndex {|tickVal|
		var idx = this.indexFromTicks(tickVal);

		if (idx.isNil) { ^0 };

		^idx + 1;
	}

	getBarOffsetTicks { |tickVal|

		var barlineTick = this.lastBarline(tickVal);

		^tickVal - barlineTick;
	}

	getBarOffset {|ticks|

		var region = this.whichRegion(ticks);
		var difference = ticks - region.start;

		if (region.isNil) {
			("No region found for tick value % in getBarOffset".format(ticks)).throw;
		};

		^(difference / region.metre.ticksPerBar).floor.asInteger;
	}

	lastBarline {|tickVal|
		var region = this.whichRegion(tickVal);

		if (region.isNil) { ^0 }

		^region.metre.lastBarline(tickVal-region.start) + region.start;
	}

	isBarAligned {|region|

		if (region.isKindOf(MetreRegion).not) {
			("isBarAligned expected MetreRegion, got %".format(region.class)).throw;
		};

		^region.start == this.lastBarline(region.start)
	}

	regionSize {|region|
		var index, current, next;

		if (region.isKindOf(MetreRegion).not) {
			("regionSize expected MetreRegion, got %".format(region.class)).throw;
		};

		index = this.regionIndex(region);
		if (index.isNil) {
			("MetreRegion not found in MetreMap").throw
		};

		^this.regionSizeFromIndex(index);
	}

	regionSizeFromIndex {|index|
		var
		current = regions[index],
		next = regions[index+1];

		if (index < 0) {
			("regionSizeFromIndex: invalid index %".format(index)).throw;
		};

		if (next.isNil) {
			^nil
		}

		^next.start - current.start
	}

	regionBarsFromIndex {|index|
		var ticks = this.regionSizeFromIndex(index);
		if (ticks.notNil) {
			^regions[index].metre.ticksToBars(ticks);
		} { ^nil }
	}

	regionBeatsFromIndex {|index|
		var ticks = this.regionSizeFromIndex(index);
		if (ticks.notNil) {
			^regions[index].metre.ticksToBeats(ticks);
		} { ^nil }
	}

	regionDivisionsFromIndex {|index|
		var ticks = this.regionSizeFromIndex(index);
		if (ticks.notNil) {
			^regions[index].metre.ticksToDivisions(ticks);
		} { ^nil }
	}

	// I think this isn't fit for purpose anymore?
	matchingRegion {|region|
		regions.do({
			arg entry;
			if (entry == region) { ^entry } { ^nil }
		})
	}

	matchingMetreRegionStart {|inRegion|

		if (inRegion.isKindOf(MetreRegion).not) {
			("matchingMetreRegionStart expected MetreRegion, got %".format(inRegion.class)).throw;
		};

		^regions.detect({ |region| region.start == inRegion.start });
	}

	matchingRegionIndex {|region|

		if (region.isKindOf(MetreRegion).not) { ^nil };

		^regions.detectIndex({arg reg; reg == region})
	}

	matchingRegionStartIndex {|region|
		if (region.isKindOf(MetreRegion).not) { ^nil };

		^regions.detectIndex({arg reg; reg.start == region.start})
	}

	isEarliest {|region|
		^regions.isEmpty or: { region < regions.first }
	}


	snapToLastBarline {|region|
		var snappedStart = this.lastBarline(region.start).asInteger;

		^MetreRegion(snappedStart, region.metre);
	}

	listEntries {
		"--- MetreMap Regions ---".postln;
		regions.do { |r, i| ("[%] %".format(i, r)).postln };
	}

	ticksToBars {|ticks|
		var bars = 0, remTicks = 0;
		var region = this.whichRegion(ticks);
		var index, rel;

		if (region.isNil) { ^nil };

		index = this.indexFromTicks(ticks);

		// Add all full regions before this one
		// doesn't run if index is 0
		index.do { |i|
			var regionBars = this.regionBarsFromIndex(i);
			bars = bars + regionBars.bars;
		};

		// Add bars + ticks within this region
		rel = region.metre.ticksToBars(ticks - region.start);
		bars = bars + rel.bars;
		remTicks = rel.ticks;

		^(bars: bars, ticks: remTicks);
	}

	ticksToBeats {|ticks|
		var beats = 0, counter = 0;
		var remBeats, thisRegionIndex, overflow;
		var thisRegion = this.whichRegion(ticks);
		var thisRegionBeats;

		// return nil if no regions
		if (thisRegion.isNil) { ^nil };

		// get number of beats to ticks from thisRegion
		thisRegionBeats = thisRegion.metre.ticksToBeats(ticks - thisRegion.start);
		remBeats = thisRegionBeats.beats;
		overflow = thisRegionBeats.ticks;

		// get region index from ticks
		thisRegionIndex = this.indexFromTicks(ticks);

		// if index is 0, no prior regions; return beats from thisRegion
		if (thisRegionIndex == 0) {
			^(beats: remBeats, ticks: overflow);
		};

		// else calculate sum of bars in all prior regions
		while { counter < thisRegionIndex } {
			beats = beats + this.regionBeatsFromIndex(counter).beats;
			counter = counter + 1;
		};

		// add prior regions to thisRegion bars and return
		^(beats: remBeats + beats, ticks: overflow);
	}

	ticksToDivisions {|ticks|
		var divisions = 0, counter = 0;
		var remDivisions, thisRegionIndex, overflow;
		var thisRegion = this.whichRegion(ticks);
		var thisRegionDivisions;

		// return nil if no regions
		if (thisRegion.isNil) { ^nil };

		// get number of bars to ticks from thisRegion
		thisRegionDivisions = thisRegion.metre.ticksToDivisions(ticks - thisRegion.start);
		remDivisions = thisRegionDivisions.divisions;
		overflow = thisRegionDivisions.ticks;

		// get region index from ticks
		thisRegionIndex = this.indexFromTicks(ticks);

		// if index is 0, no prior regions; return bars from thisRegion
		if (thisRegionIndex == 0) {
			^(divisions: remDivisions, ticks: overflow);
		};

		// else calculate sum of bars in all prior regions
		while { counter < thisRegionIndex } {
			divisions = divisions + this.regionDivisionsFromIndex(counter)[0]; // this.regionBeatsFromIndex?
			counter = counter + 1;
		};

		// add prior regions to thisRegion bars and return
		^(divisions: remDivisions + divisions, ticks: overflow);
	}

	barsToTicks {|bars|
		var ticks = 0;

		regions.do({
			arg reg, i;
			var regionBars = this.regionBarsFromIndex(i);

			if (regionBars.isNil) { ^ticks + regions[i].metre.barsToTicks(bars) };

			if ((bars - regionBars.bars).isNegative) {
				^ticks + regions[i].metre.barsToTicks(bars)
			} {
				ticks = ticks + this.regionSizeFromIndex(i);
				bars = bars - regionBars.bars;
			}
		})
	}

	barsToBeats {|bars|
		var beats = 0;

		regions.do({
			arg reg, i;
			var regionBars = this.regionBarsFromIndex(i);

			if (regionBars.isNil) { ^beats + reg.metre.barsToBeats(bars) };

			if ((bars - regionBars.bars).isNegative) {
				^beats + reg.metre.barsToBeats(bars);
			} {
				beats = beats + this.regionBeatsFromIndex(i).beats;
				bars = bars - regionBars.bars;
			}
		})
	}

	beatsToDivisions {|beats, beatOffset=0|
		var divs = 0;

		regions.do({
			arg reg, i;
			var regionBeats = this.regionBeatsFromIndex(i);

			if (regionBeats.isNil) { ^divs + reg.metre.beatsToDivisions(beats, beatOffset) };

			if ((beats - regionBeats.beats).isNegative) {
				^divs + reg.metre.beatsToDivisions(beats, beatOffset);
			} {
				divs = divs + this.regionDivisionsFromIndex(i).divisions;
				beats = beats - regionBeats.beats;
			};
		});
	}

	beatsToTicks {|beats, beatOffset=0|
		var ticks = 0;

		regions.do({
			arg reg, i;
			var regionBeats = this.regionBeatsFromIndex(i);

			if (regionBeats.isNil) { ^ticks + reg.metre.beatsToTicks(beats, beatOffset) };

			if ((beats - regionBeats.beats).isNegative) {
				^ticks + reg.metre.beatsToTicks(beats, beatOffset);
			} {
				ticks = ticks + this.regionSizeFromIndex(i);
				beats = beats - regionBeats.beats;
			}
		})
	}

	divisionsToTicks {|divs, beatOffset=0|
		var ticks = 0;

		regions.do({
			arg reg, i;
			var regionDivs = this.regionDivisionsFromIndex(i);

			if (regionDivs.isNil) { ^ticks + reg.metre.divisionsToTicks(divs, beatOffset) };

			if ((divs - regionDivs.divisions).isNegative) {
				^ticks + reg.metre.divisionsToTicks(divs, beatOffset);
			} {
				ticks = ticks + this.regionSizeFromIndex(i);
				divs = divs - regionDivs.divisions;
			}
		})
	}

	deltaBeats { |startTick, endTick|
		var totalBeats = 0;
		var pos = startTick;

		while { pos < endTick } {
			var region = this.whichRegion(pos);
			var regionEnd = this.regionSize(region) ?? endTick;
			var ticksPerBeat = region.metre.ticksPerBeat;

			var chunkEnd = endTick.min(regionEnd), tickDelta;
			chunkEnd.postln;

			tickDelta = chunkEnd - pos;

			totalBeats = totalBeats + (tickDelta / ticksPerBeat);
			pos = chunkEnd;
		};

		^totalBeats;
	}

}
+ Number {

	toPos {
		arg metremap;
		^TimeConverter.ticksToPos(this.asInteger, metremap);
	}

	toMIDIBeats { |tpqn| ^this / tpqn }

}
